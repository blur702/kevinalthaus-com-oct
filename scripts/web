#!/bin/bash
# ========================================
# Web Service Management Script
# ========================================
# Quick script to start and stop all Docker Compose services
#
# Requires Docker Compose v2 (the `docker compose` command). If you still have
# docker-compose v1 installed, please upgrade to Docker Desktop or Docker Compose v2.
#
# Usage:
#   ./scripts/web -on         Start all services
#   ./scripts/web -off        Stop all services (preserves volumes)
#   ./scripts/web -off-clean  Stop services and remove volumes (DESTRUCTIVE)
#   ./scripts/web --help      Show help
#
# The script automatically detects and kills processes using
# required ports before starting services.
# ========================================

set -e

# ========================================
# Color Constants
# ========================================
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# ========================================
# Configuration
# ========================================
PORTS=(3000 3001 3002 3003 5432 6379 8000 8080)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
COMPOSE_FILE="$PROJECT_ROOT/docker-compose.yml"
PROJECT_NAME="kevinalthaus"

# ========================================
# Utility Functions
# ========================================

log() {
    echo -e "${GREEN}[$(date +'%Y-%m-%d %H:%M:%S')]${NC} $1"
}

error() {
    echo -e "${RED}[ERROR]${NC} $1" >&2
    exit 1
}

warn() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# ========================================
# Port Management Functions
# ========================================

check_port() {
    local port=$1
    set +e
    if command -v lsof >/dev/null 2>&1; then
        lsof -t -i:$port > /dev/null 2>&1
    elif command -v ss >/dev/null 2>&1; then
        ss -ltn | awk '{print $4}' | grep -E ":$port$" >/dev/null 2>&1
    elif command -v netstat >/dev/null 2>&1; then
        netstat -ltn | awk '{print $4}' | grep -E ":$port$" >/dev/null 2>&1
    else
        warn "No port-checking tool (lsof/ss/netstat) found; cannot check port $port"
        return 1
    fi
    local result=$?
    set -e
    return $result
}

kill_port_process() {
    local port=$1
    set +e
    local pid=""
    if command -v lsof >/dev/null 2>&1; then
        pid=$(lsof -t -i:$port 2>/dev/null)
    elif command -v ss >/dev/null 2>&1; then
        pid=$(ss -lptn 'sport = :'$port 2>/dev/null | awk -F',' '/pid=/ {print $2}' | sed 's/pid=//g' | head -n1)
    elif command -v netstat >/dev/null 2>&1; then
        pid=$(netstat -lptn 2>/dev/null | awk -v p=:$port '$4 ~ p {print $7}' | cut -d'/' -f1 | head -n1)
    fi
    set -e

    if [ -n "$pid" ]; then
        local process_name=$(ps -p $pid -o comm= 2>/dev/null || echo "unknown")
        log "Sending SIGTERM to $process_name (PID: $pid) on port $port"
        kill -15 $pid 2>/dev/null || true
        # Wait up to 5 seconds for graceful shutdown
        for i in {1..5}; do
            sleep 1
            if ! check_port $port; then
                break
            fi
        done
        # Force kill if still running
        if check_port $port; then
            warn "Process still holding port $port; sending SIGKILL"
            kill -9 $pid 2>/dev/null || true
            sleep 1
        fi

        # Verify port is freed
        if check_port $port; then
            warn "Port $port still in use after killing process"
        else
            log "Port $port freed successfully"
        fi
    fi
}

check_and_kill_ports() {
    local killed_count=0

    log "Checking for port conflicts..."

    for port in "${PORTS[@]}"; do
        if check_port $port; then
            warn "Port $port is in use"
            kill_port_process $port
            ((killed_count++))
        fi
    done

    if [ $killed_count -gt 0 ]; then
        success "Cleared $killed_count port(s)"
    else
        log "All ports are available"
    fi
}

# ========================================
# Docker Compose Functions
# ========================================

start_services() {
    log "Starting services..."

    # Change to project root
    cd "$PROJECT_ROOT"

    # Check and kill conflicting processes
    check_and_kill_ports

    # Pre-flight checks for required tools
    local required=(docker jq lsof)
    for cmd in "${required[@]}"; do
        if ! command -v "$cmd" >/dev/null 2>&1; then
            warn "$cmd is not installed. Some features may not work."
        fi
    done
    # Verify Docker Compose v2 is available
    if ! docker compose version >/dev/null 2>&1; then
        error "Docker Compose v2 is required (use 'docker compose'). Please upgrade from docker-compose v1."
    fi

    # Start services
    log "Starting Docker Compose services..."
    docker compose up -d --build

    log "Services started"
}

wait_for_health() {
    log "Waiting for services to become healthy..."

    local max_wait=120
    local elapsed=0
    local interval=5

    while [ $elapsed -lt $max_wait ]; do
        set +e
        local status=$(docker compose ps --format json 2>/dev/null)
        set -e

        if [ -z "$status" ]; then
            warn "No services found, waiting..."
            sleep $interval
            ((elapsed+=interval))
            continue
        fi

        # Check if all services are healthy or running
        local all_healthy=true
        local unhealthy_count=0
        local total_count=0

        # Check if jq is available for JSON parsing
        if command -v jq &> /dev/null; then
            # Use jq to parse JSON and check health status
            while IFS= read -r line; do
                if [ -z "$line" ]; then
                    continue
                fi

                ((total_count++))

                # Get health status (prefer Health.Status, fallback to State)
                local health=$(echo "$line" | jq -r '.Health // ""' 2>/dev/null)
                local state=$(echo "$line" | jq -r '.State // ""' 2>/dev/null)
                local name=$(echo "$line" | jq -r '.Name // "unknown"' 2>/dev/null)

                if [ "$health" = "healthy" ] || [ "$state" = "running" ]; then
                    # Container is healthy or running
                    continue
                else
                    # Container is not healthy
                    all_healthy=false
                    ((unhealthy_count++))
                fi
            done <<< "$status"
        else
            # Fallback: use grep/awk to parse JSON
            total_count=$(echo "$status" | grep -c '"Name"' || echo "0")

            # Count containers that are not healthy or running
            # Look for "Health":"healthy" or "State":"running"
            local healthy_or_running=$(echo "$status" | grep -c -E '("Health":"healthy"|"State":"running")' || echo "0")

            if [ "$total_count" -gt 0 ] && [ "$healthy_or_running" -lt "$total_count" ]; then
                all_healthy=false
                unhealthy_count=$((total_count - healthy_or_running))
            fi
        fi

        if [ "$total_count" -eq 0 ]; then
            all_healthy=false
        fi

        # If all services are healthy, break out of loop
        if [ "$all_healthy" = true ] && [ "$total_count" -gt 0 ]; then
            log "All services are healthy ($total_count containers)"
            break
        fi

        # Show progress
        if [ "$unhealthy_count" -gt 0 ]; then
            echo -n "."
        else
            echo -n "."
        fi

        sleep $interval
        ((elapsed+=interval))
    done

    echo ""

    if [ $elapsed -ge $max_wait ]; then
        warn "Health check timeout reached. Some services may still be starting."
        warn "Check logs with: docker compose logs -f"
    else
        success "Services are healthy"
    fi
}

display_status() {
    log "Service Status:"
    echo ""
    docker compose ps
    echo ""

    success "Services are accessible at:"
    echo -e "  ${BLUE}API Gateway:${NC}      http://localhost:3000"
    echo -e "  ${BLUE}Main App:${NC}         http://localhost:3001"
    echo -e "  ${BLUE}Frontend:${NC}         http://localhost:3002"
    echo -e "  ${BLUE}Admin:${NC}            http://localhost:3003"
    echo -e "  ${BLUE}Python Service:${NC}   http://localhost:8000"
    echo -e "  ${BLUE}PostgreSQL:${NC}       localhost:5432"
    echo -e "  ${BLUE}Redis:${NC}            localhost:6379"
    echo ""
    log "View logs: docker compose logs -f"
    log "Stop services: $0 -off"
}

stop_services() {
    log "Stopping services..."

    cd "$PROJECT_ROOT"

    # Graceful shutdown
    docker compose down

    # Verify all containers stopped
    set +e
    local remaining=$(docker ps --filter name=${PROJECT_NAME}- --format '{{.Names}}' 2>/dev/null)
    set -e

    if [ -n "$remaining" ]; then
        warn "Some containers still running, forcing shutdown..."
        docker compose down --remove-orphans
    fi

    success "All services stopped"
}

# ========================================
# Command Handlers
# ========================================

handle_on() {
    log "Starting all services..."

    if ! start_services; then
        error "Failed to start services"
    fi

    wait_for_health
    display_status
}

handle_off() {
    log "Stopping all services..."

    if ! stop_services; then
        error "Failed to stop services"
    fi

    success "Shutdown complete at $(date +'%Y-%m-%d %H:%M:%S')"
}

handle_off_clean() {
    warn "DESTRUCTIVE: This will remove all volumes and delete stateful data!"

    # Abort in production environments
    if [ "${ENV:-}" = "production" ]; then
        error "Refusing to run --off-clean in production. Set ENV!=production to proceed."
    fi

    # Ensure backup acknowledgement
    if [ "${BACKUP_ACK:-0}" != "1" ]; then
        warn "Please ensure you have a current backup before proceeding."
        error "Set BACKUP_ACK=1 to acknowledge backups before running --off-clean."
    fi

    # Non-interactive shell guard
    if [ ! -t 0 ]; then
        if [ "${CONFIRM:-0}" != "1" ]; then
            error "Non-interactive shell detected. Provide CONFIRM=1 to proceed with --off-clean."
        fi
    else
        echo -n "Type CONFIRM to proceed: "
        read -r response
        if [ "$response" != "CONFIRM" ]; then
            log "Clean shutdown cancelled"
            return 1
        fi
    fi

    log "Stopping all services and cleaning volumes..."

    # Force stop with volume removal
    docker compose down -v --remove-orphans

    success "Clean shutdown complete - all volumes removed at $(date +'%Y-%m-%d %H:%M:%S')"
}

show_help() {
    cat << EOF
${GREEN}Web Service Management Script${NC}

Usage:
  $0 -on          Start all Docker Compose services
  $0 -off         Stop all Docker Compose services (preserves volumes)
  $0 -off-clean   Stop services and remove all volumes (DESTRUCTIVE)
  $0 --help       Show this help message

Commands:
  ${BLUE}-on${NC}
    • Detects and kills processes using ports: ${PORTS[@]}
    • Starts all Docker Compose services (postgres, api-gateway, main-app, etc.)
    • Waits for health checks to pass
    • Displays service status and URLs

  ${BLUE}-off${NC}
    • Gracefully stops all Docker Compose services
    • Verifies all containers are stopped
    • Removes orphaned containers
    • Preserves all volumes and stateful data

  ${BLUE}-off-clean${NC} ${RED}(DESTRUCTIVE)${NC}
    • Stops all Docker Compose services
    • Removes all volumes and stateful data
    • Requires confirmation before proceeding

Examples:
  # Start all services
  ./scripts/web -on

  # Stop all services (preserves data)
  ./scripts/web -off

  # Stop and clean all volumes (DESTRUCTIVE)
  ./scripts/web -off-clean

  # Make globally accessible (add to PATH)
  sudo ln -s \$(pwd)/scripts/web /usr/local/bin/web
  web -on

Services managed:
  • PostgreSQL (port 5432)
  • Redis (port 6379)
  • API Gateway (port 3000)
  • Main App (port 3001)
  • Python Service (port 8000)
  • Postgres Backup (port 8080 healthcheck)
  • Frontend (port 3002)
  • Admin (port 3003)

For more information, see scripts/README.md
EOF
}

# ========================================
# Main Script Logic
# ========================================

# Check if Docker is installed and running
if ! command -v docker &> /dev/null; then
    error "Docker is not installed. Please install Docker first."
fi

if ! docker info &> /dev/null; then
    error "Docker is not running. Please start Docker daemon."
fi

# Check if docker-compose.yml exists
if [ ! -f "$COMPOSE_FILE" ]; then
    error "docker-compose.yml not found at: $COMPOSE_FILE"
fi

# Parse command line arguments
case "${1:-}" in
    -on)
        handle_on
        ;;
    -off)
        handle_off
        ;;
    -off-clean)
        handle_off_clean
        ;;
    --help|-h)
        show_help
        exit 0
        ;;
    *)
        echo -e "${RED}Error: Invalid or missing argument${NC}\n"
        show_help
        exit 1
        ;;
esac

exit 0
